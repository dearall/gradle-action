plugins {
    id 'java'
    id 'groovy'
}

group = 'com.manning.gia.todo'
version = '1.0.0'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
        vendor = JvmVendorSpec.ADOPTOPENJDK
    }
}

//集成测试： 创建 integrationTest sourceSet
def integrationTest = sourceSets.create('integrationTest')

configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation)
configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly)

//注册添加 integrationTest task
def integrationTestTask = tasks.register('integrationTest', Test) {
    description = 'Runs integration tests.'
    group = 'verification'

    testClassesDirs = integrationTest.output.classesDirs
    classpath = configurations[integrationTest.runtimeClasspathConfigurationName] + integrationTest.output

    shouldRunAfter(tasks.named('test'))

    forkEvery = 5
    maxParallelForks = determineMaxParallelForks()

    println 'integrationTest.implementationConfigurationName: ' + integrationTest.implementationConfigurationName
    println 'integrationTest.runtimeOnlyConfigurationName: ' + integrationTest.runtimeOnlyConfigurationName
    println 'integrationTest.runtimeClasspathConfigurationName: ' + integrationTest.runtimeClasspathConfigurationName
}

tasks.withType(Test).configureEach {
    // Discover and execute JUnit4-based tests
    useJUnit() // Junit 4/3 using this feature to execute tests.

    // Discover and execute JUnit Platform-based tests
    useJUnitPlatform() // spock using this feature to execute tests.

    // With JUnit Platform, only includes and excludes are used to filter test classes
    // — scanForTestClasses has no effect.
    include '**/*'

    // Discover and execute TestNG-based tests
    // testNG using this to execute tests.
    // useTestNG()

    // listen to events in the test execution lifecycle
    /*
    beforeTest { descriptor ->
        logger.lifecycle("Running test: " + descriptor)
    }*/

    // Fail the 'test' task on the first test failure
    failFast = true

    // listen to standard out and standard error of the test JVM(s)
    /*
    onOutput { descriptor, event ->
        logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
    }*/

    testLogging {
        // show standard out and standard error of the test JVM(s) on the console
        showStandardStreams true
        // Sets the events to be logged.
        events "passed", "skipped", "failed"
    }
}

test {
    forkEvery = 5
    maxParallelForks = determineMaxParallelForks()

    println("maxParallelForks: " + maxParallelForks)
}

tasks.named('check') {
    dependsOn(integrationTestTask)
}

dependencies {
    testImplementation (libs.junit.jupiter.api)
    testRuntimeOnly (libs.junit.jupiter.engine)
    testRuntimeOnly (libs.junit.vintage.engine)

    testImplementation (libs.junit4)
    testImplementation (libs.testng)
    testImplementation (libs.spock.core)
    testImplementation (libs.spock.junit4)
    testImplementation (libs.bundles.groovy) // for spock test using groovy

    integrationTestImplementation project
}

static def determineMaxParallelForks() {
    (Runtime.runtime.availableProcessors() / 2) < 1 ? 1 : Runtime.runtime.availableProcessors() / 2
}